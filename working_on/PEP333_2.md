---
layout: post
title: "WSGI web服务网关接口(2)"
date: 2017-12-24 10:20:15 +0800
comments: true
categories: python
tags: [python,wsgi,translation,PEP]
---

> 本文译自：https://www.python.org/dev/peps/pep-0333
>
> 前一部分内容请查看：http://10111000.com/2017/12/22/PEP333_1/
>
> **tips**: 以下， 服务端代指服务端和网关， 框架端代指应用端和框架端

#### 规范细节

应用对象必须接收两个位置参数。为了更好的说明，我们把两个变量分别命名为environ和start_response,但是这个规范里并不要求和变量名完全一致。一个服务器端必须传入相应的位置参数（不是字典参数）去调用应用对象。（如上所述，我们可以以这种方式进行调用：result = application(environ, start_response)。）

<!--more-->

environ是一个字典对象，包含CGI风格的环境变量，这个对象必须是一个内置的python字典（不是一个子类，用户自定义的字典或其他拥有类似字典操作的对象），且可以被框架端任意修改成它想要的形式。这个environ也必须包含某些WSGI所需要的变量（稍后会加以详述），也可能包含服务器的某些扩展变量，按照惯例，如何命名将会在下文提及。

start_response是一个可接受两个位置参数，一个可选参数的可调用对象。同样为了说明，这个三个参数分别命名为status, response_headers 和 exc_info,它们也可以有不同的命名，框架端必须传入对应的位置参数去调用start_response方法。（例如：start_response(status, response_headers)）

status参数是一个形如“999 message here”的状态字符串，response_headers是由HTTP响应头形成的元组（header_name, header_value）在一起组成的列表，对于可选参数exc_info，我们会在start_response()调用及错误处理章节进行解释。它仅在应用程序捕获错误后并尝试向浏览器端显示错误时使用。

start_response必须返回一个可调用的对象 - write(body_data), 这个对象的调用需要一个可以作为HTTP响应主体的字符串作为位置参数（注意：write仅用于支持某些现有的框架的输出API,如果新的框架可以避免的话，就不应该再使用，这一部分细节会在缓冲和流一节进一步阐述）。

当服务端调用框架端时，框架端应该返回包含0个或多个字符串的可迭代对象，这可以通过多种方式实现，比如返回一个包含多个字符串的列表，或者一个产生字符串的生成器函数，又或者是一个可迭代的实例对象。不管它是如何完成的，框架端都应该返回满足此要求的结果。

服务端必须在响应另一个请求之前，把产生的字符串以无缓冲的方式传输到客户端。（换句话说，框架端应该有它自己的缓冲区，有关框架端如何处理输出的更多信息，请参阅下面的缓冲和流一节）。

服务端应该把产生的字符串当成二进制字节码来处理：特别是要确保行结束符不被修改。框架端则负责确保写入的字符串是适合客户端的格式。服务端可以应用HTTP传输编码，或者为了实现诸如字节范围传输的HTTP功能而执行其他转换。（参阅：其他的HTTP功能）

如果len(iterable)方法调用成功，那么服务端也会认为结果是正确的，也就是说，如果框架提供了__len__方法，那它也必须返回一个与此方法相匹配的一个结果。（请参阅处理Content-Length头部分了解如何正确使用。）

如果框架端返回的可迭代对象有close()方法的话，那么不管请求有没有正常结束或者由于错误提前中止，服务端都必须在完成当前的请求后调用该方法（这个方法是为了支持框架端的一些资源释放）。该协议旨在对PEP 325的生成器及其他拥有close()方法的可迭代对象进行支持。

（注意：框架端必须在生成第一个响应主体的字符串之前调用start_response方法，这样服务端才能在发送任何主体内容之前发送响应头，然而，这个调用可能是由迭代器的第一次迭代执行的，所以服务器不能假定start_response()方法是在迭代器开始迭代之前就已经被调用了）

最后，服务端不能直接使用由框架端返回的可迭代对象中的任何属性，除非它是一个特定服务器的实例，比如由wsgi.file_wrapper返回的file wrapper(请参阅：可选特定平台的文件处理)，一般情况下，只有这里指定的属性或通过PEP 234文档定义的API是可以使用的。

##### environ变量

environ字典需要包含如[通用网关接口规范](http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt)定义CGI环境变量。以下的变量是必须存在的，除非它们是空的字符串，在这种情况下，除非是另有说明，否则它们可能会被忽略。

| 变量名                              | 描述                                       |
| :------------------------------- | ---------------------------------------- |
| REQUEST_METHOD                   | HTTP请求方法，比如GET和POST。这个变量不能为空，所以总是需要的     |
| SCRIPT_NAME                      | 请求URL的路径对应于框架端的初始位置，框架端会根据这个变量找到对应的虚拟位置。如果这个位置是框架端的根位置的话，那么这个变量可能是一个空字符串 |
| PATH_INFO                        | 请求的URL除去SCRIPT_NAME的剩余部分，指出了请求目标在框架端的虚拟位置。如果请求的目标是这个框架的根路径且没有“/”符号结尾的话，那么这个变量可能是一个空字符串。 |
| QUERY_STRING                     | URL中紧跟“？”后的那一部分。也可能是空的字符串或者不存在此变量。       |
| CONTENT_TYPE                     | HTTP请求头Content-Type中的内容， 可能是空的字符串或者不存在此变量。 |
| CONTENT_LENGTH                   | HTTP请求头Content-Length中的内容， 可能是空的字符串或者不存在此变量。 |
| SERVER_NAME          SERVER_PORT | 当这些变量和SCRIPT_NAME，PATH_INFO拼在一起时，可以得到完整的URL。注意，如果存在HTTP_HOST的话，应该优先考虑使用HTTP_POST来重新构造请求URL.请参阅URL重建部分获取更多细节。SERVER_NAME, SERVER_PORT不能为空，所以总是需要的。 |
| SERVER_PROTOCOL                  | 用户用来发送请求的协议版本，典型的有“HTTP/1.0”或者“HTTP/1.1”和由应用程序用来确定如何处理的HTTP请求头。（这个变量也可能叫做请求协议- REQUEST_PROTOCOL，因为它表示的是请求的协议，并不一定是服务端用于响应的协议。不过为了和现有的通用网关接口兼容，我们仍然使用现在的这个变量名） |
| HTTP_VARIABLES                   | 变量对应于客户端提供的HTTP请求头（比如以“HTTP_”开头的变量）这些变量的存在或不存在应该与HTTP请求头中的变量的存在或是不存在相对应。 |

服务端应该尝试提供尽可能多适用的CGI变量。此外，如果使用了SSL，服务端还应该提供一些相应的Apache SSL环境变量。比如HTTPS = on和SSL_PROTOCOL。不过，使用上面列出CGI变量以外的任何变量的应用程序，对于不支持相关扩展的Web服务器必然是不可移植的（例如，不提供文件发布服务的服务器就不能够给出有意义的DOCUMENT_ROOT或PATH_TRANSLATED。）

一个兼容WSGI规范的服务器必以文档的形式给出它所提供的变量，以及适当的定义。框架端应该检查它所需要的任何变量是否存在，并且在有变量不存在的情况下有对应的备用方案。

缺失的变量应该排除在environ字典之外（比如没有发生认证时的REMOTE_USER），另外CGI定义的变量必须是字符串，如果CGI定义的变量为任意的其他类型而不是字符串的话都是违反本规范的。

除去CGI定义的变量，environ字典也可能包含任意的操作系统环境变量，并且必须包含如下WSGI定义的变量。

| 变量                | 值                                        |
| ----------------- | ---------------------------------------- |
| wsgi.version      | 元组（1，0），表示WSGI的版本1.0                     |
| wsgi.url_scheme   | 表示正在调用框架端的URL协议部分的字符串，一般来说值为“http”或“https”。 |
| wsgi.input        | HTTP请求主体可以读取的输入流（类文件对象）。服务端可以根据框架端的请求按需读取，或者预读客户端发来请求并缓存在内存或磁盘中，或根据自己的偏好，用其他的方式提供的输入流。 |
| wsgi.errors       | 一个输出流，可以写入错误对象，用于在标准化及中心位置记录程序及其他错误。这应该是一个“文本模式”流，比如框架端应该用“\n”来做为行结束符，并且假定服务端可以正确处理。对于大多数的服务器，wsgi.errors将是服务器端主要的错误日志，或者可能是sys.stderr，或某种类型的日志文件。服务器端应该提供相应文档解释如何配置及从哪里找到输出日志。如果需要的话，服务器端也可以提供不同的错误处理流给不同的框架端。 |
| wsgi.multithread  | 如果框架端可以在一个进程中同时被不同的线程所调用的话，那么应该设为TRUE，否则为FALSE |
| wsgi.multiprocess | 如果框架端可以同时被另外一个进程所调用的话，那么应该设为TRUE，否则为FALSE |
| wsgi.run_once     | 如果服务端期望框架端在一个进程的生命周期中只被调用一次（但不能保证），那么值应该为TRUE, 通常情况下，对于基于CGI（或类似的）的网关来说，这只会为TRUE。 |

最后，environ也可能包含服务端自定义变量，这些变量的变量名应该只能由小写字母，数字，点和下划线组成，并且应该以定义的服务器或网关唯一的名称作为前缀。例如，mod_python 自定义的变量可能为mod_python.some_variable的形式。

###### 输入和错误流

服务端提供的输入和错误流必须支持以下方法。

| Method          | Stream | Notes |
| --------------- | ------ | ----- |
| read(size)      | input  | 1     |
| readline()      | input  | 1,2   |
| readlines(hint) | input  | 1,3   |
| __iter__()      | input  |       |
| flush           | errors | 4     |
| write(str)      | errors |       |
| writelines(seq) | errors |       |

上述每种方法的定义可以参考Python库中的定义，下面则是上表中Notes的一个说明：

1. 服务器不需要读取超过客户端指定长度的内容，如果客户端尝试读取超过内容长度的点时，服务端可以模拟一个文件结束条件强制结束。框架端不应该读取超过content-length中定义的长度的内容。
2. 可选的size参数，对于这里的readline函数来说是不支持的，因为其不太易于实现，在实际中也不太用的到。
3. hint参数对于调用者和实现者来说都是可选的，框架端可以不提供，服务端也可以忽略它。
4. 因为错误可能不能重现，所以服务端可以执行写操作而不经过缓冲区。在这种情况下，flush()可能是个空操作。不过，框架端不能假设这个输出是不缓冲的或flush()是个空操作。如果想要确保输出被写入，则必须调用flush()方法。（例如：最大限度地减少来自多个进程的数据混合写入一个相同的错误日志）

上面列出的方法都必须被遵循这个规范的服务端支持，框架端也应该不使用其他任何方法或input及errors对象的属性。需要指出的是，框架端不要尝试关闭这些流，即使它们拥有close()方法。

##### 可调用的start_response函数

第二个传给框架端的参数是一个可